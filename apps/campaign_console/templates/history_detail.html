{% extends 'base.html' %} {% block content %}
{% set sent_count = send.SENT_COUNT|int %}
{% set failed_count = send.FAILED_COUNT|int %}
{% set total = send.TOTAL_RECIPIENTS|int %}
{% set pending_count = (total - sent_count - failed_count)|int %}
{% set attempted = (sent_count + failed_count)|int %}
<div class="history-detail">
  <section class="hero hero-utility">
    <div class="hero-copy">
      <p class="eyebrow">Campaign detail</p>
      <h2>{{ send.CAMPAIGN_NAME or send.CAMPAIGN_FILE }}</h2>
      <p class="muted">
        File: {{ send.CAMPAIGN_FILE }}
        {% if send.SUBJECT %} · Subject: {{ send.SUBJECT }}{% endif %}
      </p>
    </div>
    <div class="confirm-meta">
      <div class="confirm-meta__item">
        <p class="eyebrow">Mode</p>
        <p class="confirm-meta__value">
          <span class="badge badge--{{ send.MODE }}">{{ send.MODE|capitalize }}</span>
        </p>
      </div>
      <div class="confirm-meta__item">
        <p class="eyebrow">Status</p>
        <p class="confirm-meta__value">
          <span class="badge badge--{{ send.STATUS }}" id="historyDetailStatusBadge">{{ send.STATUS|capitalize }}</span>
        </p>
      </div>
      <div class="confirm-meta__item">
        <p class="eyebrow">Date</p>
        <p class="confirm-meta__value">
          {% if send.STARTED_AT %}
          <time
            class="history-detail__time"
            data-datetime="{{ send.STARTED_AT.isoformat() }}Z"
          >
            {{ send.STARTED_AT.strftime('%b %d, %Y at %I:%M %p') }}
          </time>
          {% else %}
          —
          {% endif %}
        </p>
      </div>
      {% if send.FINISHED_AT and send.STARTED_AT %}
      <div class="confirm-meta__item">
        <p class="eyebrow">Duration</p>
        <p class="confirm-meta__value">
          {% set delta = (send.FINISHED_AT - send.STARTED_AT).total_seconds()|int %}
          {% if delta >= 60 %}
          {{ delta // 60 }}m {{ delta % 60 }}s
          {% else %}
          {{ delta }}s
          {% endif %}
        </p>
      </div>
      {% endif %}
    </div>
  </section>

  {% if send.STATUS in ('running', 'paused', 'queued') %}
  <section class="card confirm-send" id="progressSection" style="margin-bottom:1.5rem">
    <header class="card-header">
      <div>
        <h3>Send progress</h3>
      </div>
      <div class="confirm-controls-actions" id="sendActions">
        {% set st = send.STATUS %}
        <button type="button" class="button outline" id="btnPause" {% if st != 'running' %}hidden{% endif %}>Pause</button>
        <button type="button" class="button primary" id="btnResume" {% if st != 'paused' %}hidden{% endif %}>Resume</button>
        <button type="button" class="button" id="btnCancel" {% if st not in ('running', 'paused') %}hidden{% endif %} style="color:var(--color-error,#c0392b)">Cancel</button>
      </div>
    </header>
    <p class="muted" style="font-size:0.85rem;margin:0 0 0.75rem;">
      Pause and resume affect new batches only. Cancelling stops any further batches from starting;
      emails already in the current batch will still finish sending or fail.
    </p>
    <div class="progress-bar-container" style="margin-bottom:1rem">
      <div style="display:flex;justify-content:space-between;font-size:0.85rem;margin-bottom:0.25rem">
        <span id="progressLabel">{{ attempted }} / {{ total }}</span>
        <span id="progressPercent">{% if total %}{{ ((attempted / total) * 100)|round(0) }}{% else %}0{% endif %}%</span>
      </div>
      <div style="background:var(--color-surface-alt,#eee);border-radius:4px;height:8px;overflow:hidden">
        <div id="progressFill" style="background:var(--color-accent,#2ecc71);height:100%;width:{% if total %}{{ ((attempted / total) * 100)|round(0) }}{% else %}0{% endif %}%;transition:width 0.3s"></div>
      </div>
      <div style="display:flex;gap:1.5rem;font-size:0.85rem;margin-top:0.5rem;color:var(--color-muted,#888)">
        <span>Sent: <strong id="progressSent">{{ sent_count }}</strong></span>
        <span>Failed: <strong id="progressFailed">{{ failed_count }}</strong></span>
        <span>Pending: <strong id="progressPending">{{ pending_count }}</strong></span>
      </div>
      <p class="muted" id="nextBatchInfo" style="margin-top:0.35rem;font-size:0.8rem;">
        Next batch timing will appear here when there is pending work.
      </p>
      <p class="muted" id="etaInfo" style="margin-top:0.15rem;font-size:0.8rem;">
        Estimated completion time will appear here while the campaign is running.
      </p>
    </div>
  </section>
  {% endif %}

  <div class="history-detail__grid">
    <section class="card history-summary">
      <h3>Summary</h3>
      <div class="history-summary__legend">
        <span class="history-summary__legend-item">
          <span class="history-summary__legend-dot history-summary__legend-dot--sent"></span>
          <span class="history-summary__legend-text">Sent {{ sent_count }}</span>
        </span>
        <span class="history-summary__legend-item">
          <span class="history-summary__legend-dot history-summary__legend-dot--failed"></span>
          <span class="history-summary__legend-text">Failed {{ failed_count }}</span>
        </span>
        <span class="history-summary__legend-item">
          <span class="history-summary__legend-dot history-summary__legend-dot--pending"></span>
          <span class="history-summary__legend-text">Pending {{ pending_count if pending_count > 0 else 0 }}</span>
        </span>
      </div>
      <div class="history-summary__stats">
        <div class="history-summary__stat">
          <span class="history-summary__stat-value">{{ total }}</span>
          <span class="history-summary__stat-label">Total recipients</span>
        </div>
        <div class="history-summary__stat">
          <span class="history-summary__stat-value history-summary__stat-value--sent">{{ sent_count }}</span>
          <span class="history-summary__stat-label">Sent</span>
        </div>
        <div class="history-summary__stat">
          <span class="history-summary__stat-value history-summary__stat-value--failed">{{ failed_count }}</span>
          <span class="history-summary__stat-label">Failed</span>
        </div>
        <div class="history-summary__stat">
          <span class="history-summary__stat-value">{{ pending_count if pending_count > 0 else 0 }}</span>
          <span class="history-summary__stat-label">Pending</span>
        </div>
        {% if attempted > 0 %}
        <div class="history-summary__stat">
          <span class="history-summary__stat-value">{{ ((sent_count / attempted) * 100)|round(1) }}%</span>
          <span class="history-summary__stat-label">Success rate (of attempted)</span>
        </div>
        {% endif %}
      </div>
      {% if send.STATUS == 'cancelled' %}
      <p class="muted" style="margin-top:0.75rem;font-size:0.85rem;">
        This send was cancelled. Some recipients may remain in a pending state because cancellation
        stops new batches from starting but does not interrupt emails already being processed.
      </p>
      {% endif %}
    </section>

    <section class="card history-results">
      <header class="card-header">
        <div>
          <h3>Recipient results</h3>
          <p class="muted">{{ all_results|length }} result{{ 's' if all_results|length != 1 else '' }} recorded</p>
        </div>
        <div class="history-results__filter" role="group" aria-label="Filter by status">
          <a
            href="{{ url_for('campaign_history_detail', send_id=send.SEND_ID) }}"
            class="button {% if status_filter == 'all' %}accent{% else %}ghost{% endif %}"
          >All</a>
          <a
            href="{{ url_for('campaign_history_detail', send_id=send.SEND_ID, status='sent') }}"
            class="button {% if status_filter == 'sent' %}accent{% else %}ghost{% endif %}"
          >Sent</a>
          <a
            href="{{ url_for('campaign_history_detail', send_id=send.SEND_ID, status='failed') }}"
            class="button {% if status_filter == 'failed' %}accent{% else %}ghost{% endif %}"
          >Failed</a>
          <a
            href="{{ url_for('campaign_history_detail', send_id=send.SEND_ID, status='pending') }}"
            class="button {% if status_filter == 'pending' %}accent{% else %}ghost{% endif %}"
          >Pending</a>
        </div>
      </header>

      {% if results %}
      <div class="recipient-table-scroll">
        <table class="history-results__table">
          <thead>
            <tr>
              <th scope="col">#</th>
              <th scope="col">Email</th>
              <th scope="col">First name</th>
              <th scope="col">Last name</th>
              <th scope="col">Status</th>
              <th scope="col">Error</th>
            </tr>
          </thead>
          <tbody>
            {% for r in results %}
            <tr class="history-results__row--{{ r.STATUS }}">
              <td>{{ loop.index }}</td>
              <td>{{ r.EMAIL }}</td>
              <td>{{ r.FIRSTNAME or '—' }}</td>
              <td>{{ r.LASTNAME or '—' }}</td>
              <td>
                {% set status_class = 'status-pill muted' %}
                {% if r.STATUS == 'sent' %}
                  {% set status_class = 'status-pill success' %}
                {% elif r.STATUS == 'failed' %}
                  {% set status_class = 'status-pill danger' %}
                {% endif %}
                <span class="{{ status_class }}">{{ r.STATUS|capitalize }}</span>
              </td>
              <td class="history-results__error">{{ r.ERROR_MESSAGE or '—' }}</td>
            </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
      {% else %}
      <p class="muted" style="padding: 1rem;">No results match this filter.</p>
      {% endif %}
    </section>
  </div>

  <div class="confirm-footer card soft">
    <a href="{{ url_for('campaign_history') }}" class="button ghost full-width">Back to campaign history</a>
  </div>
</div>
<script>
  (function () {
    const nodes = document.querySelectorAll("[data-datetime]");
    nodes.forEach((el) => {
      const raw = el.getAttribute("data-datetime");
      if (!raw) return;
      let d = new Date(raw);
      if (Number.isNaN(d.getTime())) {
        d = new Date(raw + "Z");
        if (Number.isNaN(d.getTime())) return;
      }
      try {
        el.textContent = d.toLocaleString(undefined, {
          year: "numeric",
          month: "short",
          day: "numeric",
          hour: "numeric",
          minute: "2-digit",
        });
      } catch {
        // ignore formatting errors
      }
    });
  })();
</script>
{% if send.STATUS in ('running', 'paused', 'queued') %}
<script>
(function () {
  const sendId = {{ send.SEND_ID|tojson }};
  const meta = document.querySelector('meta[name="csrf-token"]');
  const csrfToken = meta ? (meta.getAttribute("content") || "") : "";

  function csrfHeaders(extra) {
    const h = { "X-Requested-With": "XMLHttpRequest", "X-CSRF-Token": csrfToken, ...extra };
    return h;
  }

  const progressLabel = document.getElementById("progressLabel");
  const progressPercent = document.getElementById("progressPercent");
  const progressFill = document.getElementById("progressFill");
  const progressSent = document.getElementById("progressSent");
  const progressFailed = document.getElementById("progressFailed");
  const progressPending = document.getElementById("progressPending");
  const statusBadge = document.getElementById("historyDetailStatusBadge");
  const btnPause = document.getElementById("btnPause");
  const btnResume = document.getElementById("btnResume");
  const btnCancel = document.getElementById("btnCancel");
  const nextBatchInfo = document.getElementById("nextBatchInfo");
  const etaInfo = document.getElementById("etaInfo");

  let pollTimer = null;

  function formatDurationShort(seconds) {
    const s = Math.max(0, Math.round(seconds || 0));
    if (s < 60) return "under 1 minute";
    const hours = Math.floor(s / 3600);
    const minutes = Math.round((s % 3600) / 60);
    if (hours && minutes) return `~${hours}h ${minutes}m`;
    if (hours) return `~${hours}h`;
    return `~${minutes}m`;
  }

  function updateButtons(status) {
    if (statusBadge) statusBadge.textContent = (status || "").charAt(0).toUpperCase() + (status || "").slice(1);
    if (btnPause) btnPause.hidden = status !== "running";
    if (btnResume) btnResume.hidden = status !== "paused";
    if (btnCancel) btnCancel.hidden = !(status === "running" || status === "paused");
    const isActive = status === "running" || status === "paused" || status === "queued";
    if (!isActive && pollTimer) {
      clearInterval(pollTimer);
      pollTimer = null;
    }
  }

  async function pollProgress() {
    try {
      const resp = await fetch("/send/" + encodeURIComponent(sendId) + "/progress");
      if (!resp.ok) return;
      const d = await resp.json();
      const sent = d.sent || 0;
      const failed = d.failed || 0;
      const total = d.total || 1;
      const pending = d.pending || 0;
      const done = sent + failed;
      const pct = Math.round((done / total) * 100);
      progressLabel.textContent = done + " / " + total;
      progressPercent.textContent = pct + "%";
      progressFill.style.width = pct + "%";
      progressSent.textContent = sent;
      progressFailed.textContent = failed;
      progressPending.textContent = pending;

      if (etaInfo) {
        const status = d.status || "";
        if (total > 0 && done > 0 && (status === "running" || status === "paused" || status === "queued") && !d.finished_at && d.started_at) {
          let startedAt = new Date(d.started_at);
          if (Number.isNaN(startedAt.getTime())) startedAt = new Date(d.started_at + "Z");
          if (!Number.isNaN(startedAt.getTime())) {
            const now = new Date();
            const elapsedMs = now.getTime() - startedAt.getTime();
            const fraction = done / total;
            if (fraction > 0 && elapsedMs > 0) {
              const totalMsEstimate = elapsedMs / fraction;
              const remainingMs = Math.max(0, totalMsEstimate - elapsedMs);
              const remainingSeconds = Math.round(remainingMs / 1000);
              const finishTime = new Date(now.getTime() + remainingMs);
              const finishLabel = finishTime.toLocaleTimeString(undefined, { hour: "numeric", minute: "2-digit" });
              etaInfo.textContent = "Estimated completion around " + finishLabel + " (" + formatDurationShort(remainingSeconds) + " remaining).";
            } else {
              etaInfo.textContent = "";
            }
          } else {
            etaInfo.textContent = "";
          }
        } else if (status === "completed" || status === "cancelled" || status === "failed") {
          etaInfo.textContent = "Campaign finished.";
        } else {
          etaInfo.textContent = "";
        }
      }

      if (nextBatchInfo) {
        const status = d.status || "";
        if ((status === "running" || status === "paused" || status === "queued") && pending > 0) {
          const cooldownSeconds = d.cooldown_seconds || 0;
          if (!cooldownSeconds) {
            nextBatchInfo.textContent = "Batches are continuous; the next batch starts immediately.";
          } else {
            const lastBatchAt = d.last_batch_at ? new Date(d.last_batch_at) : null;
            let nextTime = null;
            if (lastBatchAt && !Number.isNaN(lastBatchAt.getTime())) {
              nextTime = new Date(lastBatchAt.getTime() + cooldownSeconds * 1000);
            } else if (d.started_at) {
              const startedAt = new Date(d.started_at);
              if (!Number.isNaN(startedAt.getTime())) nextTime = new Date(startedAt.getTime() + cooldownSeconds * 1000);
            }
            if (nextTime) {
              const now = new Date();
              const deltaMs = nextTime.getTime() - now.getTime();
              if (deltaMs <= 0) {
                nextBatchInfo.textContent = "Next batch is ready to send.";
              } else {
                const deltaSec = Math.round(deltaMs / 1000);
                if (deltaSec < 60) {
                  nextBatchInfo.textContent = "Next batch in under 1 minute.";
                } else {
                  const minutes = Math.round(deltaSec / 60);
                  const hours = Math.floor(minutes / 60);
                  const remMinutes = minutes % 60;
                  nextBatchInfo.textContent = hours ? (remMinutes ? "Next batch in ~" + hours + "h " + remMinutes + "m." : "Next batch in ~" + hours + "h.") : "Next batch in ~" + minutes + "m.";
                }
              }
            } else {
              nextBatchInfo.textContent = "Next batch will start shortly.";
            }
          }
        } else {
          nextBatchInfo.textContent = "No additional batches are scheduled.";
        }
      }

      updateButtons(d.status);
    } catch (err) {
      console.error("Progress poll failed:", err);
    }
  }

  pollProgress();
  pollTimer = setInterval(pollProgress, 3000);

  async function postAction(action) {
    try {
      const resp = await fetch("/send/" + encodeURIComponent(sendId) + "/" + action, {
        method: "POST",
        headers: csrfHeaders({ "Content-Type": "application/json" }),
      });
      const data = await resp.json();
      if (data.status) updateButtons(data.status);
      pollProgress();
    } catch (err) {
      console.error(action + " failed:", err);
    }
  }

  if (btnPause) btnPause.addEventListener("click", () => postAction("pause"));
  if (btnResume) btnResume.addEventListener("click", () => postAction("resume"));
  if (btnCancel) btnCancel.addEventListener("click", function () {
    if (confirm("Are you sure you want to cancel this campaign send? Remaining emails will not be sent.")) {
      postAction("cancel");
    }
  });
})();
</script>
{% endif %}
{% endblock %}
