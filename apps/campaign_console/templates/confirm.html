{% extends 'base.html' %} {% block content %}
{% set resolved_recipient_count = recipient_count if recipient_count is not none else (recipients|length if recipients else 0) %}
<div class="confirm-page" data-confirm-page>
  <section class="hero hero-utility confirm-hero">
    <div class="hero-copy">
      <p class="eyebrow">{% if sending %}Campaign progress{% else %}Queue campaign{% endif %}</p>
      <h2>
        {% if campaign_name %}
          {{ campaign_name }}
        {% elif sending %}
          {{ file }}
        {% else %}
          Confirm campaign
        {% endif %}
      </h2>
      <p>{% if sending %}Track progress, adjust pacing, or pause/cancel the send.{% else %}Review the content, pacing, and recipients before queuing.{% endif %}</p>
    </div>
    <div class="confirm-meta">
      <div class="confirm-meta__item">
        <p class="eyebrow">Campaign file</p>
        <p class="confirm-meta__value">{{ file }}</p>
      </div>
      <div class="confirm-meta__item">
        <p class="eyebrow">Subject</p>
        <p class="confirm-meta__value">{{ subject }}</p>
      </div>
      <div class="confirm-meta__item">
        <p class="eyebrow">Recipients</p>
        <p class="confirm-meta__value" id="metaRecipientCount">{{ resolved_recipient_count }}</p>
      </div>
      {% if sending %}
      <div class="confirm-meta__item">
        <p class="eyebrow">Status</p>
        <p class="confirm-meta__value" id="metaStatus">{{ send_status or "running" }}</p>
      </div>
      {% endif %}
    </div>
  </section>

  <div class="confirm-grid">

    {% if sending %}
    <section class="card confirm-send" id="progressSection">
      <header class="card-header">
        <div>
          <h3>Send progress</h3>
        </div>
        <div class="confirm-controls-actions" id="sendActions">
          {% set st = send_status or "running" %}
          <button type="button" class="button outline" id="btnPause" {% if st != 'running' %}hidden{% endif %}>Pause</button>
          <button type="button" class="button primary" id="btnResume" {% if st != 'paused' %}hidden{% endif %}>Resume</button>
          <button type="button" class="button" id="btnCancel" {% if st not in ('running', 'paused') %}hidden{% endif %} style="color:var(--color-error,#c0392b)">Cancel</button>
        </div>
      </header>

      <p class="muted" style="font-size:0.85rem;margin:0 0 0.75rem;">
        Pause and resume affect new batches only. Cancelling stops any further batches from starting;
        emails already in the current batch will still finish sending or fail.
      </p>

      <div class="progress-bar-container" style="margin-bottom:1rem">
        <div style="display:flex;justify-content:space-between;font-size:0.85rem;margin-bottom:0.25rem">
          <span id="progressLabel">0 / {{ resolved_recipient_count }}</span>
          <span id="progressPercent">0%</span>
        </div>
        <div style="background:var(--color-surface-alt,#eee);border-radius:4px;height:8px;overflow:hidden">
          <div id="progressFill" style="background:var(--color-accent,#2ecc71);height:100%;width:0%;transition:width 0.3s"></div>
        </div>
        <div style="display:flex;gap:1.5rem;font-size:0.85rem;margin-top:0.5rem;color:var(--color-muted,#888)">
          <span>Sent: <strong id="progressSent">{{ sent_count|default(0) }}</strong></span>
          <span>Failed: <strong id="progressFailed">{{ failed_count|default(0) }}</strong></span>
          <span>Pending: <strong id="progressPending">—</strong></span>
        </div>
        <p class="muted" id="nextBatchInfo" style="margin-top:0.35rem;font-size:0.8rem;">
          Next batch timing will appear here when there is pending work.
        </p>
        <p class="muted" id="etaInfo" style="margin-top:0.15rem;font-size:0.8rem;">
          Estimated completion time will appear here while the campaign is running.
        </p>
      </div>

      <div class="confirm-form-grid" id="controlsForm">
        <label>
          <span>Batch size</span>
          <input type="number" id="ctrlBatchSize" min="1" value="{{ batch_size }}" />
        </label>
        <label>
          <span>Delay per email (seconds)</span>
          <input type="number" id="ctrlDelayMs" min="0" value="{{ delay_ms }}" />
        </label>
        <label>
          <span>Cooldown between batches (minutes)</span>
          <input type="number" id="ctrlCooldown" min="0" value="{{ cooldown_seconds }}" />
        </label>
        <button type="button" class="button secondary" id="btnSaveControls" {% if (send_status or "running") in ('completed', 'failed', 'cancelled') %}disabled{% endif %}>Save controls</button>
      </div>
    </section>

    <section class="card confirm-recipients" id="recipientListSection">
      <header class="card-header">
        <div>
          <p class="eyebrow">Recipients</p>
          <h3>Recipient status</h3>
        </div>
        <div style="display:flex;gap:0.5rem;align-items:center">
          <select id="recipientStatusFilter" style="font-size:0.85rem">
            <option value="">All</option>
            <option value="pending">Pending</option>
            <option value="sent">Sent</option>
            <option value="failed">Failed</option>
          </select>
        </div>
      </header>
      <div class="recipient-table-scroll">
        <table id="recipientTable">
          <thead>
            <tr>
              <th scope="col">#</th>
              <th scope="col">Email</th>
              <th scope="col">First name</th>
              <th scope="col">Last name</th>
              <th scope="col">Status</th>
              <th scope="col">Error</th>
            </tr>
          </thead>
          <tbody id="recipientTableBody">
            <tr><td colspan="6" class="muted" style="text-align:center">Loading...</td></tr>
          </tbody>
        </table>
      </div>
      <div id="recipientPagination" style="display:flex;justify-content:space-between;align-items:center;margin-top:0.75rem;font-size:0.85rem">
        <span id="recipientPageInfo"></span>
        <div style="display:flex;gap:0.5rem">
          <button type="button" class="button ghost" id="recipientPrev" disabled>Previous</button>
          <button type="button" class="button ghost" id="recipientNext" disabled>Next</button>
        </div>
      </div>
    </section>

    {% else %}

    <section class="card preview-panel confirm-preview">
      <header class="card-header">
        <div>
          <p class="eyebrow">Campaign preview</p>
          <h3>{{ file }}</h3>
        </div>
      </header>
      {% if preview_html %}
      <iframe id="confirmPreviewFrame" class="preview-frame" title="Email preview"></iframe>
      {% else %}
      <div class="preview-error card muted">
        {{ preview_error or "Preview unavailable. Return to the dashboard to reload the preview." }}
      </div>
      {% endif %}
    </section>

    <section class="lint-summary card soft confirm-lint-summary">
      <h3>Lint report</h3>
      {% if lint_has_errors %}
      <p class="lint-summary__status lint-summary__status--error">
        Queuing is blocked until the following lint errors are fixed.
      </p>
      {% elif lint_has_warnings %}
      <p class="lint-summary__status lint-summary__status--warning">
        Warnings were found. Review them below, but you may proceed.
      </p>
      {% else %}
      <p class="lint-summary__status lint-summary__status--ok">No lint issues detected.</p>
      {% endif %}
      {% if lint_report.errors %}
      <h4>Errors</h4>
      <ul>
        {% for err in lint_report.errors %}
        <li>{{ err }}</li>
        {% endfor %}
      </ul>
      {% endif %}
      {% if lint_report.warnings %}
      <h4>Warnings</h4>
      <ul>
        {% for warning in lint_report.warnings %}
        <li>{{ warning }}</li>
        {% endfor %}
      </ul>
      {% endif %}
      {% if lint_report.notes %}
      <h4>Notes</h4>
      <ul>
        {% for note in lint_report.notes %}
        <li>{{ note }}</li>
        {% endfor %}
      </ul>
      {% endif %}
    </section>

    {% if recipients %}
    {% set preview_limit = 5 %}
    <section class="card confirm-recipients">
      <header class="card-header">
        <div>
          <p class="eyebrow">Recipients</p>
          <h3>Recipient preview</h3>
        </div>
      </header>
      <div class="recipient-list">
        <div class="recipient-list__header">
          <p class="muted">Showing up to {{ preview_limit }} rows by default</p>
          {% if recipients|length > preview_limit %}
          <button
            id="recipient-toggle"
            type="button"
            class="button ghost recipient-list__toggle"
            aria-expanded="false"
          >
            Show all recipients ({{ recipients|length - preview_limit }} more)
          </button>
          {% endif %}
        </div>
        <div class="recipient-table-scroll">
          <table id="recipient-table" data-preview-limit="{{ preview_limit }}">
            <thead>
              <tr>
                <th scope="col">#</th>
                <th scope="col">First name</th>
                <th scope="col">Last name</th>
                <th scope="col">Email</th>
              </tr>
            </thead>
            <tbody>
              {% for customer in recipients %}
              <tr>
                <td>{{ loop.index }}</td>
                <td>{{ customer["FIRSTNAME"] }}</td>
                <td>{{ customer["LASTNAME"] }}</td>
                <td>{{ customer["EMAIL"] }}</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </section>
    {% else %}
    <section class="card confirm-recipients">
      <p>No subscribed customers are available to receive this campaign.</p>
    </section>
    {% endif %}

    <section class="card confirm-send">
      <header class="card-header">
        <div>
          <h3>Queue campaign</h3>
        </div>
      </header>
      <form method="post" action="/queue">
        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}" />
        <input type="hidden" name="file" value="{{ file }}" />
        <input type="hidden" name="subject" value="{{ subject }}" />
        <input type="hidden" name="campaign_name" value="{{ campaign_name or '' }}" />

        <div class="confirm-form-grid">
          <label>
            <span>Batch size</span>
            <input type="number" name="batch_size" min="1" value="{{ batch_size }}" />
          </label>
          <label>
            <span>Delay per email (seconds)</span>
            <input type="number" name="delay_seconds" min="0" value="{{ delay_seconds }}" />
          </label>
          <label>
            <span>Cooldown between batches (minutes)</span>
            <input type="number" name="cooldown_minutes" min="0" value="{{ cooldown_minutes }}" />
          </label>
        </div>

        {% if estimated_send_time %}
        <p class="confirm-estimate muted">
          Estimated total send time:
          <strong id="estimatedSendTime">{{ estimated_send_time }}</strong>
          for
          <span id="estimatedRecipientCount">{{ recipient_count }}</span>
          recipient{{ "s" if recipient_count != 1 else "" }}.
          The send runs in the background — you can sign out and return later.
        </p>
        {% endif %}

        {% if lint_has_errors %}
        <p class="lint-blocker">Fix the lint errors above to enable the queue button.</p>
        {% elif lint_has_warnings %}
        <p class="lint-warning">Warnings were detected, but queuing is still allowed.</p>
        {% endif %}

        <button
          type="submit"
          class="button accent full-width"
          {% if lint_has_errors %}disabled aria-disabled="true"{% endif %}
        >
          Queue campaign
        </button>
      </form>
    </section>
    {% endif %}
  </div>
  <div class="confirm-footer card soft">
    <a href="{{ url_for('index') }}" class="button ghost full-width">Return to homepage</a>
  </div>
</div>

{% if not sending and recipients and recipients|length > preview_limit %}
<script>
  (function () {
    const table = document.getElementById("recipient-table");
    const toggle = document.getElementById("recipient-toggle");
    if (!table || !toggle) return;

    const previewLimit = parseInt(table.dataset.previewLimit || "0", 10);
    const rows = Array.from(table.querySelectorAll("tbody tr"));

    function render(expanded) {
      rows.forEach((row, idx) => {
        const shouldShow = expanded || idx < previewLimit;
        row.style.display = shouldShow ? "" : "none";
      });
      toggle.dataset.expanded = expanded ? "true" : "false";
      toggle.setAttribute("aria-expanded", expanded ? "true" : "false");
      if (expanded) {
        toggle.textContent = "Collapse recipient list";
      } else {
        const remaining = Math.max(rows.length - previewLimit, 0);
        toggle.textContent =
          remaining > 0
            ? `Show all recipients (${remaining} more)`
            : "Show recipients";
      }
    }

    toggle.addEventListener("click", () => {
      const expanded = toggle.dataset.expanded === "true";
      render(!expanded);
    });

    render(false);
  })();
</script>
{% endif %}
{% if not sending and preview_html %}
<script>
  (function () {
    const frame = document.getElementById("confirmPreviewFrame");
    if (!frame) return;
    const html = {{ preview_html|tojson|safe }};
    frame.srcdoc = html || "";
  })();
</script>
{% endif %}
{% if sending %}
<script>
(function () {
  const sendId = {{ (send_id or "")|tojson }};
  const csrfToken = {{ csrf_token()|tojson }};

  function csrfHeaders(extra) {
    const h = { "X-Requested-With": "XMLHttpRequest", "X-CSRF-Token": csrfToken, ...extra };
    return h;
  }

  /* ── Progress polling ─────────────────────────────────────── */
  const progressLabel = document.getElementById("progressLabel");
  const progressPercent = document.getElementById("progressPercent");
  const progressFill = document.getElementById("progressFill");
  const progressSent = document.getElementById("progressSent");
  const progressFailed = document.getElementById("progressFailed");
  const progressPending = document.getElementById("progressPending");
  const metaStatus = document.getElementById("metaStatus");
  const btnPause = document.getElementById("btnPause");
  const btnResume = document.getElementById("btnResume");
  const btnCancel = document.getElementById("btnCancel");
  const btnSaveControls = document.getElementById("btnSaveControls");
  const ctrlBatchSize = document.getElementById("ctrlBatchSize");
  const ctrlDelayMs = document.getElementById("ctrlDelayMs");
  const ctrlCooldown = document.getElementById("ctrlCooldown");
  const nextBatchInfo = document.getElementById("nextBatchInfo");
  const etaInfo = document.getElementById("etaInfo");

  let currentStatus = {{ (send_status or "running")|tojson }};
  let pollTimer = null;

  function formatDurationShort(seconds) {
    const s = Math.max(0, Math.round(seconds || 0));
    if (s < 60) return "under 1 minute";
    const hours = Math.floor(s / 3600);
    const minutes = Math.round((s % 3600) / 60);
    if (hours && minutes) return `~${hours}h ${minutes}m`;
    if (hours) return `~${hours}h`;
    return `~${minutes}m`;
  }

  function updateButtons(status) {
    currentStatus = status;
    if (metaStatus) metaStatus.textContent = status;
    const isActive = status === "running" || status === "paused" || status === "queued";
    btnPause.hidden = status !== "running";
    btnResume.hidden = status !== "paused";
    btnCancel.hidden = !(status === "running" || status === "paused");
    btnSaveControls.disabled = !isActive;
    ctrlBatchSize.disabled = !isActive;
    ctrlDelayMs.disabled = !isActive;
    ctrlCooldown.disabled = !isActive;

    if (!isActive && pollTimer) {
      clearInterval(pollTimer);
      pollTimer = null;
    }
  }

  async function pollProgress() {
    try {
      const resp = await fetch(`/send/${encodeURIComponent(sendId)}/progress`);
      if (!resp.ok) return;
      const d = await resp.json();
      const sent = d.sent || 0;
      const failed = d.failed || 0;
      const total = d.total || 1;
      const pending = d.pending || 0;
      const done = sent + failed;
      const pct = Math.round((done / total) * 100);
      progressLabel.textContent = `${done} / ${total}`;
      progressPercent.textContent = `${pct}%`;
      progressFill.style.width = `${pct}%`;
      progressSent.textContent = sent;
      progressFailed.textContent = failed;
      progressPending.textContent = pending;
      if (d.batch_size && ctrlBatchSize && !ctrlBatchSize.matches(":focus"))
        ctrlBatchSize.value = d.batch_size;
      if (d.delay_ms != null && ctrlDelayMs && !ctrlDelayMs.matches(":focus"))
        ctrlDelayMs.value = Math.round(d.delay_ms / 1000);
      if (d.cooldown_seconds != null && ctrlCooldown && !ctrlCooldown.matches(":focus"))
        ctrlCooldown.value = Math.round(d.cooldown_seconds / 60);

      if (etaInfo) {
        const status = d.status || "";
        if (
          total > 0 &&
          done > 0 &&
          (status === "running" || status === "paused" || status === "queued") &&
          !d.finished_at &&
          d.started_at
        ) {
          let startedAt = new Date(d.started_at);
          if (Number.isNaN(startedAt.getTime())) {
            startedAt = new Date(d.started_at + "Z");
          }
          if (!Number.isNaN(startedAt.getTime())) {
            const now = new Date();
            const elapsedMs = now.getTime() - startedAt.getTime();
            const fraction = done / total;
            if (fraction > 0 && elapsedMs > 0) {
              const totalMsEstimate = elapsedMs / fraction;
              const remainingMs = Math.max(0, totalMsEstimate - elapsedMs);
              const remainingSeconds = Math.round(remainingMs / 1000);
              const finishTime = new Date(now.getTime() + remainingMs);
              const finishLabel = finishTime.toLocaleTimeString(undefined, {
                hour: "numeric",
                minute: "2-digit",
              });
              const remainingLabel = formatDurationShort(remainingSeconds);
              etaInfo.textContent = `Estimated completion around ${finishLabel} (${remainingLabel} remaining).`;
            } else {
              etaInfo.textContent = "";
            }
          } else {
            etaInfo.textContent = "";
          }
        } else if (status === "completed" || status === "cancelled" || status === "failed") {
          etaInfo.textContent = "Campaign finished.";
        } else {
          etaInfo.textContent = "";
        }
      }

      if (nextBatchInfo) {
        const status = d.status || "";
        if ((status === "running" || status === "paused" || status === "queued") && pending > 0) {
          const cooldownSeconds = d.cooldown_seconds || 0;
          if (!cooldownSeconds) {
            nextBatchInfo.textContent = "Batches are continuous; the next batch starts immediately.";
          } else {
            const lastBatchAt = d.last_batch_at ? new Date(d.last_batch_at) : null;
            let nextTime = null;
            if (lastBatchAt && !Number.isNaN(lastBatchAt.getTime())) {
              nextTime = new Date(lastBatchAt.getTime() + cooldownSeconds * 1000);
            } else if (d.started_at) {
              const startedAt = new Date(d.started_at);
              if (!Number.isNaN(startedAt.getTime())) {
                nextTime = new Date(startedAt.getTime() + cooldownSeconds * 1000);
              }
            }
            if (nextTime) {
              const now = new Date();
              const deltaMs = nextTime.getTime() - now.getTime();
              if (deltaMs <= 0) {
                nextBatchInfo.textContent = "Next batch is ready to send.";
              } else {
                const deltaSec = Math.round(deltaMs / 1000);
                if (deltaSec < 60) {
                  nextBatchInfo.textContent = "Next batch in under 1 minute.";
                } else {
                  const minutes = Math.round(deltaSec / 60);
                  const hours = Math.floor(minutes / 60);
                  const remMinutes = minutes % 60;
                  if (hours) {
                    if (remMinutes) {
                      nextBatchInfo.textContent = `Next batch in ~${hours}h ${remMinutes}m.`;
                    } else {
                      nextBatchInfo.textContent = `Next batch in ~${hours}h.`;
                    }
                  } else {
                    nextBatchInfo.textContent = `Next batch in ~${minutes}m.`;
                  }
                }
              }
            } else {
              nextBatchInfo.textContent = "Next batch will start shortly.";
            }
          }
        } else {
          nextBatchInfo.textContent = "No additional batches are scheduled.";
        }
      }

      updateButtons(d.status);
    } catch (err) {
      console.error("Progress poll failed:", err);
    }
  }

  pollProgress();
  pollTimer = setInterval(pollProgress, 3000);

  /* ── Pause / Resume / Cancel ─────────────────────────────── */
  async function postAction(action) {
    try {
      const resp = await fetch(`/send/${encodeURIComponent(sendId)}/${action}`, {
        method: "POST",
        headers: csrfHeaders({ "Content-Type": "application/json" }),
      });
      const data = await resp.json();
      if (data.status) updateButtons(data.status);
      pollProgress();
    } catch (err) {
      console.error(`${action} failed:`, err);
    }
  }

  btnPause.addEventListener("click", () => postAction("pause"));
  btnResume.addEventListener("click", () => postAction("resume"));
  btnCancel.addEventListener("click", () => {
    if (confirm("Are you sure you want to cancel this campaign send? Remaining emails will not be sent.")) {
      postAction("cancel");
    }
  });

  /* ── Save controls ───────────────────────────────────────── */
  btnSaveControls.addEventListener("click", async () => {
    try {
      btnSaveControls.disabled = true;
      btnSaveControls.textContent = "Saving...";
      const body = {
        batch_size: parseInt(ctrlBatchSize.value, 10) || 1,
        delay_ms: (parseInt(ctrlDelayMs.value, 10) || 0) * 1000,
        cooldown_seconds: (parseInt(ctrlCooldown.value, 10) || 0) * 60,
      };
      await fetch(`/send/${encodeURIComponent(sendId)}/controls`, {
        method: "PATCH",
        headers: csrfHeaders({ "Content-Type": "application/json" }),
        body: JSON.stringify(body),
      });
      btnSaveControls.textContent = "Saved!";
      setTimeout(() => {
        btnSaveControls.textContent = "Save controls";
        btnSaveControls.disabled = !(currentStatus === "running" || currentStatus === "paused" || currentStatus === "queued");
      }, 1500);
    } catch (err) {
      btnSaveControls.textContent = "Save controls";
      btnSaveControls.disabled = false;
      console.error("Save controls failed:", err);
    }
  });

  /* ── Recipient table ─────────────────────────────────────── */
  const recipientTableBody = document.getElementById("recipientTableBody");
  const recipientPageInfo = document.getElementById("recipientPageInfo");
  const recipientPrev = document.getElementById("recipientPrev");
  const recipientNext = document.getElementById("recipientNext");
  const recipientStatusFilter = document.getElementById("recipientStatusFilter");
  const RECIPIENT_PAGE_SIZE = 50;
  let recipientOffset = 0;
  let recipientTotal = 0;

  async function loadRecipients() {
    const status = recipientStatusFilter.value;
    const params = new URLSearchParams({ limit: RECIPIENT_PAGE_SIZE, offset: recipientOffset });
    if (status) params.set("status", status);
    try {
      const resp = await fetch(`/send/${encodeURIComponent(sendId)}/recipients?${params}`);
      if (!resp.ok) throw new Error("Failed to load");
      const data = await resp.json();
      recipientTotal = data.total || 0;
      renderRecipientTable(data.recipients || []);
    } catch (err) {
      recipientTableBody.innerHTML = '<tr><td colspan="6" class="muted" style="text-align:center">Unable to load recipients.</td></tr>';
    }
  }

  function renderRecipientTable(rows) {
    if (!rows.length) {
      recipientTableBody.innerHTML = '<tr><td colspan="6" class="muted" style="text-align:center">No recipients found.</td></tr>';
    } else {
      recipientTableBody.innerHTML = rows.map((r, i) => {
        const idx = recipientOffset + i + 1;
        const statusPillClass =
          r.status === "sent"
            ? "status-pill success"
            : r.status === "failed"
            ? "status-pill danger"
            : "status-pill muted";
        const statusLabel = (r.status || "").charAt(0).toUpperCase() + (r.status || "").slice(1);
        return `<tr>
          <td>${idx}</td>
          <td>${escapeHtml(r.email)}</td>
          <td>${escapeHtml(r.firstname || "")}</td>
          <td>${escapeHtml(r.lastname || "")}</td>
          <td><span class="${statusPillClass}">${escapeHtml(statusLabel)}</span></td>
          <td>${escapeHtml(r.error || "")}</td>
        </tr>`;
      }).join("");
    }
    const start = recipientTotal > 0 ? recipientOffset + 1 : 0;
    const end = Math.min(recipientOffset + RECIPIENT_PAGE_SIZE, recipientTotal);
    recipientPageInfo.textContent = `${start}–${end} of ${recipientTotal}`;
    recipientPrev.disabled = recipientOffset <= 0;
    recipientNext.disabled = recipientOffset + RECIPIENT_PAGE_SIZE >= recipientTotal;
  }

  function escapeHtml(s) {
    const d = document.createElement("div");
    d.textContent = s;
    return d.innerHTML;
  }

  recipientPrev.addEventListener("click", () => {
    recipientOffset = Math.max(0, recipientOffset - RECIPIENT_PAGE_SIZE);
    loadRecipients();
  });
  recipientNext.addEventListener("click", () => {
    recipientOffset += RECIPIENT_PAGE_SIZE;
    loadRecipients();
  });
  recipientStatusFilter.addEventListener("change", () => {
    recipientOffset = 0;
    loadRecipients();
  });
  loadRecipients();
  setInterval(loadRecipients, 10000);

  })();
})();
</script>
{% endif %}
<script>
  (function () {
    const root = document.querySelector("[data-confirm-page]");
    if (!root) return;
    let reloadRequested = false;
    window.addEventListener("db-mode-changed", (event) => {
      if (reloadRequested) return;
      reloadRequested = true;
      const modeLabel = event?.detail?.mode === "test" ? "test" : "production";
      try {
        const notice = document.createElement("p");
        notice.className = "lint-warning";
        notice.textContent = `Reloading confirmation for ${modeLabel} mode…`;
        root.prepend(notice);
      } catch (err) {
        /* ignore */
      }
      window.setTimeout(() => window.location.reload(), 200);
    });
  })();
  (function () {
    const estimateEl = document.getElementById("estimatedSendTime");
    const recipientCountEl = document.getElementById("estimatedRecipientCount");
    const batchInput = document.querySelector('input[name="batch_size"]');
    const delayInput = document.querySelector('input[name="delay_seconds"]');
    const cooldownInput = document.querySelector('input[name="cooldown_minutes"]');
    if (!estimateEl || !recipientCountEl || !batchInput || !delayInput || !cooldownInput) return;

    const baseRecipients = parseInt(recipientCountEl.textContent || "0", 10) || 0;

    function formatDuration(seconds) {
      const s = Math.max(0, Math.round(seconds || 0));
      if (s < 60) return "under 1 minute";
      const hours = Math.floor(s / 3600);
      const minutes = Math.round((s % 3600) / 60);
      if (hours && minutes) return `~${hours}h ${minutes}m`;
      if (hours) return `~${hours}h`;
      return `~${minutes}m`;
    }

    function recalcEstimate() {
      if (!baseRecipients) return;
      const batchSize = Math.max(1, parseInt(batchInput.value, 10) || 1);
      const delaySeconds = Math.max(0, parseInt(delayInput.value, 10) || 0);
      const cooldownMinutes = Math.max(0, parseInt(cooldownInput.value, 10) || 0);
      const cooldownSeconds = cooldownMinutes * 60;
      const numBatches = Math.max(1, Math.ceil(baseRecipients / batchSize));
      const totalCooldown = Math.max(0, numBatches - 1) * cooldownSeconds;
      const estimatedSeconds = totalCooldown + baseRecipients * delaySeconds;
      estimateEl.textContent = formatDuration(estimatedSeconds);
    }

    batchInput.addEventListener("input", recalcEstimate);
    delayInput.addEventListener("input", recalcEstimate);
    cooldownInput.addEventListener("input", recalcEstimate);
  })();
</script>
{% endblock %}
